# 权利之歌大地图寻路优化

1. 因为地图天然的具有格子属性，所以寻路基于基于格子的A-Star 
2. 权利之歌使用六边形格子，每个格子有直接相邻的6个邻居，使用的坐标系统为2维笛卡尔坐标，偶数行的地格向右平移半格 
3. 视觉优化之一，加入二级邻居，新增了六个方向，尤其是多了直上直下，视觉上美化很多。 
4. 视觉优化之二，直线化。AStar特殊处理之距离估值函数，不能使用实际直线距离，而需要用网格距离，需要一种简便的方法，准确的计算出两个六边形格子的格子距离。实现的策略为，首先定义两个基础向量dx(0.5,1) dy(-0.5,1)，分别代表六边形相邻格的右上和左上方向，方向右(1,0)可以通过右上减去左上得到；任意两个点的距离则可以通过解方程组得到在dx和dy方向上的步数；因为一个基础向量dx和一个异号的基础向量dy相加，可以得到一个右，相当于两步合并为一步；所以得到的方程解，可以异号合并同号消减步数到最低；然后再考虑二级邻居，一个dx与一个dy相加可以得到一个二级邻居，相当于把步长为1的两步合并成步长为1.732的一步；

```
float CalcDis(int srcx, int srcy, int dstx, int dsty){
	srcx = srcx * 2 + (srcy % 2 == 0 ? 1 : 0);
       srcy = srcy * 2;
       dstx = dstx * 2 + (dsty % 2 == 0 ? 1 : 0);
       dsty = dsty * 2;
       
       int xDis = dstx - srcx;
       int yDis = dsty - srcy;
       
      //dx(1, 2)
      //dy(-1, 2)
       //dz(2, 0)
      //dx * x + dy * y = (原来的坐标)
      //(1, 2) * x + (-1, 2) * y = (xDis, yDis)
      //x - y = xDis
       //2x + 2y = yDis
     //x - y = xDis
       //x + y = yDis / 2
       int x = (xDis + yDis / 2)/2;
       int y = (yDis / 2 - xDis)/2;
       
       //if (Math.Abs(x + y) < (Math.Abs(x) + Math.Abs(y))){
       if (x * y < 0){
           int nx = Math.Abs(x + y);
           int ny = Math.Min(Math.Abs(x), Math.Abs(y));
           x = nx;
           y = ny;
       }
       int rx = Math.Max(Math.Abs(x), Math.Abs(y));
       int ry = Math.Min(Math.Abs(x), Math.Abs(y));
       
       return (rx - ry + ry * 1.732f);
   }
}
```

5. 视觉优化之三，拐角smooth
6. MarchLine裁剪

A星的排序优化 -2叉堆的插入和(弹出最小值)，复杂度为log(n) -但是难点在于，有时要改变随机节点的值，这个时候对二叉堆的重新整理就是一个问题 -考虑到在AStar方法中，从来都是把节点的值改小(找到了到这个地图点更近的路线)，所以可以向上递归，重新整理树的这一支线

A星寻路的二叉堆优化方法 初始网格(1024*1024)里，存放网格状态，原来是none/open/close，现在改成指向二叉堆的索引，-1代表none中，-2代表close，其他值代表在二叉堆中的索引。二叉堆整理，交换元素时，实时更新初始网格的索引。并且二叉堆的节点里，保存已经过的距离。 初始网格里放已经过的距离会增大内存，而且对none和close无意义； 如果初始网格只放状态，不放索引，整理二叉堆之前，还需要搜索改变节点在二叉堆里的位置。
